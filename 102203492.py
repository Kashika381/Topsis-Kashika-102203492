# -*- coding: utf-8 -*-
"""102203492.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zQVpfYfScRV69bZxl2wvezKk2PvWl5lr
"""



from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import os

# Function to check if input is numeric
def is_numeric(value):
    try:
        float(value)
        return True
    except ValueError:
        return False

# Function to normalize the decision matrix
def normalize_matrix(df):
    norm_df = df.iloc[:, 1:].apply(lambda x: np.sqrt((x**2).sum()), axis=0)
    normalized_matrix = df.iloc[:, 1:].div(norm_df, axis=1)
    return normalized_matrix

# Function to apply weights
def apply_weights(normalized_matrix, weights):
    weighted_matrix = normalized_matrix * weights
    return weighted_matrix

# Function to calculate ideal and negative-ideal solutions
def ideal_solutions(weighted_matrix, impacts):
    ideal_solution = []
    negative_ideal_solution = []
    for i, col in enumerate(weighted_matrix.columns):
        if impacts[i] == '+':
            ideal_solution.append(weighted_matrix[col].max())
            negative_ideal_solution.append(weighted_matrix[col].min())
        else:
            ideal_solution.append(weighted_matrix[col].min())
            negative_ideal_solution.append(weighted_matrix[col].max())
    return np.array(ideal_solution), np.array(negative_ideal_solution)

# Function to calculate distances to ideal and negative-ideal solutions
def calculate_distances(weighted_matrix, ideal_solution, negative_ideal_solution):
    distance_to_ideal = np.sqrt(((weighted_matrix - ideal_solution)**2).sum(axis=1))
    distance_to_negative_ideal = np.sqrt(((weighted_matrix - negative_ideal_solution)**2).sum(axis=1))
    return distance_to_ideal, distance_to_negative_ideal

# Function to calculate Topsis score
def calculate_topsis_score(distance_to_ideal, distance_to_negative_ideal):
    return distance_to_negative_ideal / (distance_to_ideal + distance_to_negative_ideal)

# Main function
def topsis(input_file, weights_str, impacts_str, result_file):
    # Read the input data
    if not os.path.exists(input_file):
        print(f"Error: File '{input_file}' not found.")
        return

    try:
        df = pd.read_csv(input_file)
    except Exception as e:
        print(f"Error: Could not read file '{input_file}'. {e}")
        return

    # Check if the number of columns is at least 3
    if len(df.columns) < 3:
        print("Error: Input file must contain at least 3 columns.")
        return

    # Validate that all values from the 2nd column onwards are numeric
    for col in df.columns[1:]:
        if not all(df[col].apply(is_numeric)):
            print(f"Error: Column '{col}' contains non-numeric values.")
            return

    # Parse the weights and impacts
    try:
        weights = np.array([float(w) for w in weights_str.split(',')])
        impacts = impacts_str.split(',')
    except ValueError:
        print("Error: Weights and impacts must be comma-separated numbers.")
        return

    # Validate weights, impacts and number of columns
    if len(weights) != len(df.columns) - 1:
        print(f"Error: The number of weights must match the number of criteria columns ({len(df.columns) - 1}).")
        return

    if len(impacts) != len(df.columns) - 1:
        print(f"Error: The number of impacts must match the number of criteria columns ({len(df.columns) - 1}).")
        return

    # Normalize the decision matrix
    normalized_matrix = normalize_matrix(df)

    # Apply the weights to the normalized matrix
    weighted_matrix = apply_weights(normalized_matrix, weights)

    # Calculate ideal and negative-ideal solutions
    ideal_solution, negative_ideal_solution = ideal_solutions(weighted_matrix, impacts)

    # Calculate distances to ideal and negative-ideal solutions
    distance_to_ideal, distance_to_negative_ideal = calculate_distances(weighted_matrix, ideal_solution, negative_ideal_solution)

    # Calculate the Topsis score
    topsis_score = calculate_topsis_score(distance_to_ideal, distance_to_negative_ideal)

    # Rank the alternatives based on Topsis score
    df['Topsis Score'] = topsis_score
    df['Rank'] = topsis_score.rank(ascending=False).astype(int)

    # Write the result to the output file
    df.to_csv(result_file, index=False)
    print(f"Results saved to '{result_file}'.")

# Entry point for the script
if __name__ == "__main__":
    # Specify your own values below
    input_file = '/content/drive/MyDrive/3492-data.csv'  # Your input CSV path
    weights_str = '1,1,1,1,1'  # 5 weights for 5 criteria (P1 to P5)
    impacts_str = '+,+,-,+,+'  # 5 impacts for the 5 criteria
    result_file = '3492_result.csv'  # Output CSV path

    topsis(input_file, weights_str, impacts_str, result_file)

import pandas as pd

# Load the result.csv file
df = pd.read_csv('3492_result.csv')

# Print the content
print(df)